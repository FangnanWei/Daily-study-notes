
大连研发部

主要是做MCU的 
不对口 

随便问了两个问题  

C语言中static

- 修饰局部变量时，使得该变量在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问；
- 修饰全局变量时，使得该变量在静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在文件外是不可见的；
- 修饰函数时，在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同名的函数冲突；
- 修饰成员变量时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加`static`；
- 修饰成员函数时，该函数不接受`this`指针，只能访问类的静态成员；不需要实例化对象即可访问。

全局变量和局部变量能重复吗

```cpp
1. #include <stdio.h>

3. int n = 10;  //全局变量

5. void func1(){
6.     int n = 20;  //局部变量
7.     printf("func1 n: %d\n", n);
8. }

10. void func2(int n){
11.     printf("func2 n: %d\n", n);
12. }

14. void func3(){
15.     printf("func3 n: %d\n", n);
16. }

18. int main(){
19.     int n = 30;  //局部变量
20.     func1();
21.     func2(n);
22.     func3();
23.     //代码块由{}包围
24.     {
25.         int n = 40;  //局部变量
26.         printf("block n: %d\n", n);
27.     }
28.     printf("main n: %d\n", n);

30.     return 0;
31. }
```

运行结果：  
func1 n: 20  
func2 n: 30  
func3 n: 10  
block n: 40  
main n: 30  
  
代码中虽然定义了多个同名变量 n，但它们的作用域不同，在内存中的位置（地址）也不同，所以是相互独立的变量，互不影响，不会产生`重复定义（Redefinition）`错误。  
  
1) 对于 func1()，输出结果为 20，显然使用的是函数内部的 n，而不是外部的 n；func2() 也是相同的情况。  
  
当全局变量和局部变量同名时，在局部范围内全局变量被“屏蔽”，不再起作用。或者说，变量的使用遵循就近原则，如果在当前作用域中存在同名变量，就不会向更大的作用域中去寻找变量。  
  
2) func3() 输出 10，使用的是全局变量，因为在 func3() 函数中不存在局部变量 n，所以编译器只能到函数外部，也就是全局作用域中去寻找变量 n。  
  
3) 由`{ }`包围的代码块也拥有独立的作用域，printf() 使用它自己内部的变量 n，输出 40。  
  
4) C语言规定，只能从小的作用域向大的作用域中去寻找变量，而不能反过来，使用更小的作用域中的变量。对于 main() 函数，即使代码块中的 n 离输出语句更近，但它仍然会使用 main() 函数开头定义的 n，所以输出结果是 30。
