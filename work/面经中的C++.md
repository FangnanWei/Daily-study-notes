
# C++中的虚函数是用来干什么的


# 多线程和多进程的区别


# 32位和64位操作系统编程的区别

32位操作系统的内存限制为4GB，它只能对2^32个字节的内存进行地址分配。这限制了32位操作系统在处理需要大量内存的任务时的性能。

64位操作系统则没有这个限制，它可以对更大的内存进行地址分配，因此能够更有效地处理大型的数据和任务。

# C++中malloc/free 和new/delete的区别


# 指针和引用的区别



# shell命令

[shell脚本]([一篇教会你写90%的shell脚本 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/264346586))


# 二叉树递归

**如果需要搜索整棵二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。**

如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？

搜索一条边的写法：
```
if (递归函数(root->left)) return ;

if (递归函数(root->right)) return ;
```
搜索整个树写法：
```
left = 递归函数(root->left);  // 左
right = 递归函数(root->right); // 右
left与right的逻辑处理;         // 中 
```
看出区别了没？

**在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）**。

那么为什么要遍历整棵树呢？直观上来看，找到最近公共祖先，直接一路返回就可以了。

**那么我给大家归纳如下三点**：

求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从底向上的遍历方式。

在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。

要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。

# 指针常量 常量指针

![image](https://cdn.staticaly.com/gh/andyye1999/picx-images-hosting@master/20230511/image.2xrwxuw0g500.webp)

# 大顶堆 优先队列

[剑指 Offer 41. 数据流中的中位数](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof)

[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements)

[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum) 单调队列或者优先队列  

[23. 合并K个排序链表](https://leetcode.cn/problems/merge-k-sorted-lists)



```cpp
less<int> // 大顶堆
greater<int> // 小顶堆 
priority_queue<int,vector<int>,less<int>> maxHeap;
```

要么
```cpp
struct cmp
{
	bool operator()(int a,int b)
	{
		return a < b;  // 大顶堆
	}
};
```

而且 是 top 不是 front
# 万能头文件 

```cpp
#include <bits/stdc++.h>
```

# 排序

冒泡排序：从左到右遍历，两两比较大小并交换位置，一次遍历下来后最右侧为最值

快速排序：一次遍历后，数组被分为＜=num和＞num的两部分，递推执行

归并排序：递归的分裂数组，然后进行小子序列的排序，然后将有序的子序列进行归并，最终得到完全有序的序列

# ASCII码

[ASCII码一览表，ASCII码对照表 (biancheng.net)](http://c.biancheng.net/c/ascii/)

小写字母比大写字母大

# 向上取整 向下取整

[(31条消息) 取整函数（ceil、floor、round）_aouixh的博客-CSDN博客](https://blog.csdn.net/aouixh/article/details/53483556)

ceil 天花板的意思 向上取整  
floor  地板 向下取整 

# static

- 修饰**局部变量**时，使得该变量在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问；
- 修饰**全局变量**时，使得该变量在静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在文件外是不可见的；
- 修饰**函数**时，在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时**避免同名的函数冲突**；
- 修饰成员变量时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加`static`；
- 修饰成员函数时，该函数不接受`this`指针，只能访问类的静态成员；不需要实例化对象即可访问。

# 全局变量和局部变量能重复吗

```cpp
1. #include <stdio.h>

3. int n = 10;  //全局变量

5. void func1(){
6.     int n = 20;  //局部变量
7.     printf("func1 n: %d\n", n);
8. }

10. void func2(int n){
11.     printf("func2 n: %d\n", n);
12. }

14. void func3(){
15.     printf("func3 n: %d\n", n);
16. }

18. int main(){
19.     int n = 30;  //局部变量
20.     func1();
21.     func2(n);
22.     func3();
23.     //代码块由{}包围
24.     {
25.         int n = 40;  //局部变量
26.         printf("block n: %d\n", n);
27.     }
28.     printf("main n: %d\n", n);

30.     return 0;
31. }
```

运行结果：  
func1 n: 20  
func2 n: 30  
func3 n: 10  
block n: 40  
main n:  30  


代码中虽然定义了多个同名变量 n，但它们的作用域不同，在内存中的位置（地址）也不同，所以是相互独立的变量，互不影响，不会产生`重复定义（Redefinition）`错误。  
  
1) 对于 func1()，输出结果为 20，显然使用的是函数内部的 n，而不是外部的 n；func2() 也是相同的情况。  
  
当全局变量和局部变量同名时，在局部范围内全局变量被“屏蔽”，不再起作用。或者说，变量的使用遵循就近原则，如果在当前作用域中存在同名变量，就不会向更大的作用域中去寻找变量。  
  
2) func3() 输出 10，使用的是全局变量，因为在 func3() 函数中不存在局部变量 n，所以编译器只能到函数外部，也就是全局作用域中去寻找变量 n。  
  
3) 由`{ }`包围的代码块也拥有独立的作用域，printf() 使用它自己内部的变量 n，输出 40。  
  
4) C语言规定，只能从小的作用域向大的作用域中去寻找变量，而不能反过来，使用更小的作用域中的变量。对于 main() 函数，即使代码块中的 n 离输出语句更近，但它仍然会使用 main() 函数开头定义的 n，所以输出结果是 30。
