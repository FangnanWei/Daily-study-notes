
# C++中的虚函数是用来干什么的


# 多线程和多进程的区别


# 32位和64位操作系统编程的区别


CPU一次可处理的数据大小区别，这影响操作系统所支持的内存寻址地址大小、以及相关的运算器、寄存器等硬件的所支持处理的数据大小，进而导致64位的操作系统可以支持更大的文件和内外存的存储空间。

32位操作系统的内存限制为4GB，它只能对2^32个字节的内存进行地址分配。这限制了32位操作系统在处理需要大量内存的任务时的性能。

64位操作系统则没有这个限制，它可以对更大的内存进行地址分配，因此能够更有效地处理大型的数据和任务。

# C++中malloc/free 和new/delete的区别


# 指针和引用的区别

# int与unsigned int之间的运算与比较


int 会转成unsigned int 不过需要源码 补码 
[(33条消息) int与unsigned int之间的运算与比较_int和unsigned int比较_西南小镇的博客-CSDN博客](https://blog.csdn.net/u012675103/article/details/45953183)

[(33条消息) 【C++】两个例子解决 unsigned int 与 int 运算问题_RiceVan的博客-CSDN博客](https://blog.csdn.net/RiceVan/article/details/108336848)

# shell命令

[shell脚本]([一篇教会你写90%的shell脚本 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/264346586))


# 二叉树递归

**如果需要搜索整棵二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。**

如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？

搜索一条边的写法：
```
if (递归函数(root->left)) return ;

if (递归函数(root->right)) return ;
```
搜索整个树写法：
```
left = 递归函数(root->left);  // 左
right = 递归函数(root->right); // 右
left与right的逻辑处理;         // 中 
```
看出区别了没？

**在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）**。

那么为什么要遍历整棵树呢？直观上来看，找到最近公共祖先，直接一路返回就可以了。

**那么我给大家归纳如下三点**：

求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从底向上的遍历方式。

在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。

要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。

# 指针常量 常量指针

![image](https://cdn.staticaly.com/gh/andyye1999/picx-images-hosting@master/20230511/image.2xrwxuw0g500.webp)

# 大顶堆 优先队列

[剑指 Offer 41. 数据流中的中位数](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof)

[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements)

[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum) 单调队列或者优先队列  

[23. 合并K个排序链表](https://leetcode.cn/problems/merge-k-sorted-lists)



```cpp
less<int> // 大顶堆
greater<int> // 小顶堆 
priority_queue<int,vector<int>,less<int>> maxHeap;
```

要么
```cpp
struct cmp
{
	bool operator()(int a,int b)
	{
		return a < b;  // 大顶堆
	}
};
```

而且 是 top 不是 front
# 万能头文件 

```cpp
#include <bits/stdc++.h>
```

# 排序

冒泡排序：从左到右遍历，两两比较大小并交换位置，一次遍历下来后最右侧为最值

快速排序：一次遍历后，数组被分为＜=num和＞num的两部分，递推执行

归并排序：递归的分裂数组，然后进行小子序列的排序，然后将有序的子序列进行归并，最终得到完全有序的序列

# ASCII码

[ASCII码一览表，ASCII码对照表 (biancheng.net)](http://c.biancheng.net/c/ascii/)

小写字母比大写字母大
大写字母+32等于小写字母  

A 65 a 97 0：48
# 向上取整 向下取整

[(31条消息) 取整函数（ceil、floor、round）_aouixh的博客-CSDN博客](https://blog.csdn.net/aouixh/article/details/53483556)

ceil 天花板的意思 向上取整  
floor  地板 向下取整 

# static

- 修饰**局部变量**时，使得该变量在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问；
- 修饰**全局变量**时，使得该变量在静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在文件外是不可见的；
- 修饰**函数**时，在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时**避免同名的函数冲突**；
- 修饰成员变量时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加`static`；
- 修饰成员函数时，该函数不接受`this`指针，只能访问类的静态成员；不需要实例化对象即可访问。

# 全局变量和局部变量能重复吗

```cpp
1. #include <stdio.h>

3. int n = 10;  //全局变量

5. void func1(){
6.     int n = 20;  //局部变量
7.     printf("func1 n: %d\n", n);
8. }

10. void func2(int n){
11.     printf("func2 n: %d\n", n);
12. }

14. void func3(){
15.     printf("func3 n: %d\n", n);
16. }

18. int main(){
19.     int n = 30;  //局部变量
20.     func1();
21.     func2(n);
22.     func3();
23.     //代码块由{}包围
24.     {
25.         int n = 40;  //局部变量
26.         printf("block n: %d\n", n);
27.     }
28.     printf("main n: %d\n", n);

30.     return 0;
31. }
```

运行结果：  
func1 n: 20  
func2 n: 30  
func3 n: 10  
block n: 40  
main n:  30  


代码中虽然定义了多个同名变量 n，但它们的作用域不同，在内存中的位置（地址）也不同，所以是相互独立的变量，互不影响，不会产生`重复定义（Redefinition）`错误。  
  
1) 对于 func1()，输出结果为 20，显然使用的是函数内部的 n，而不是外部的 n；func2() 也是相同的情况。  
  
当全局变量和局部变量同名时，在局部范围内全局变量被“屏蔽”，不再起作用。或者说，变量的使用遵循就近原则，如果在当前作用域中存在同名变量，就不会向更大的作用域中去寻找变量。  
  
2) func3() 输出 10，使用的是全局变量，因为在 func3() 函数中不存在局部变量 n，所以编译器只能到函数外部，也就是全局作用域中去寻找变量 n。  
  
3) 由`{ }`包围的代码块也拥有独立的作用域，printf() 使用它自己内部的变量 n，输出 40。  
  
4) C语言规定，只能从小的作用域向大的作用域中去寻找变量，而不能反过来，使用更小的作用域中的变量。对于 main() 函数，即使代码块中的 n 离输出语句更近，但它仍然会使用 main() 函数开头定义的 n，所以输出结果是 30。

# 排序算法

[1.0 十大经典排序算法 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html)

[【C++】十大排序（冒泡、选择、插入、希尔、归并、快排、堆、计数、桶、基数） - 排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-an-array/solution/by-peaceful-thompsonfsu-b3bu/)


常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：

![](https://www.runoob.com/wp-content/uploads/2019/03/sort.png)

点击以下图片查看大图：

[![](https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png)](https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png)
# 对于一个已经大部分排序的数组用哪种排序方法好

插入排序

# STL中的sort

[C++一道深坑面试题：STL里sort算法用的是什么排序算法？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/36274119)

STL的sort算法，数据量大时采用**QuickSort快排算法**，分段归并排序。一旦分段后的数据量小于某个门槛（16），为避免QuickSort快排的递归调用带来过大的额外负荷，就改用**Insertion Sort插入排序**。如果递归层次过深，还会改用**HeapSort堆排序**。

![](https://pic1.zhimg.com/80/v2-8fa032e195365f77fb6b980a4ed71958_720w.webp)

# 为什么前序和后序不能确定二叉树

**前序和后序在本质上都是将父节点与子结点进行分离,但并没有指明左子树和右子树的能力,因此得到这两个序列只能明确父子关系, 而不能确定一个二叉树**。

# 位运算

剑指15 n(n&1) 求该数二进制有多少个1

# **extern "C"**

C++来说，支持函数的重载，编译后的函数一般是以函数名和形参类型来命名的。

例如函数**void fun(int, int)，编译后的可能是_fun_int_int(不同编译器可能不同，但都采用了类似的机制，用函数名和参数类型来命名编译后的函数名)；而C语言没有类似的重载机制，一般是利用函数名来指明编译后的函数名的，对应上面的函数可能会是_fun这样的名字。**

# define和const有什么区别？


- 编译器处理方式不同：`#define`宏是在**预处理**阶段展开，不能对宏定义进行调试，而`const`常量是在**编译**阶段使用；
- 类型和安全检查不同：`#define`宏没有类型，不做任何类型检查，仅仅是代码展开，可能产生边际效应等错误，而`const`常量有具体类型，在编译阶段会执行**类型**检查；
- 存储方式不同：`#define`宏仅仅是代码展开，在多个地方进行字符串替换，**不会分配内存**，存储于程序的代码段中，而`const`常量会**分配内存**，但只维持一份拷贝，存储于程序的数据段中。
- 定义域不同：`#define`宏不受定义域限制，而`const`常量只在定义域内有效。


# 指针和引用的区别

非空区别： 引用必须指向某些对象
使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；
可修改区别 指针可以被重新赋值指向另一个不同的对象 引用总是指向在初始化时指定的对象

使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；
指针可以有多级指针（**p），而引用止于一级

# 组合 排列 子集

46全排列
77组合
78子集

# 背包问题

问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);

```cpp
void test_1_wei_bag_problem() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}
```
416 1049
问装满背包有几种方法：dp[j] += dp[j - nums[i]]
**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。
494 518 377 
问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);

322 279

# 浮点数

某个32位浮点数，符号位1位，指数位8位，尾数部分23位，问该浮点数最大能表述的正数是多少？
一个32位浮点数遵循IEEE 754标准，其结构如下：  
  
- 符号位（1位）：表示正数（0）或负数（1）  
- 指数位（8位）：表示指数的偏移值  
- 尾数部分（23位）：表示有效数字的小数部分  
  
要计算32位浮点数能表示的最大正数，我们需要考虑以下因素：  
  
1. 符号位为0，表示正数。  
2. 指数位的最大值为11111110（二进制），因为全1（11111111）是保留给特殊值（例如无穷大和NaN）的。所以，最大指数值为254（十进制），但需要减去偏移值127，得到实际最大指数127。  
3. 尾数部分的最大值为全1（11111111111111111111111，二进制）。将这个二进制数转换为十进制小数，我们得到1 - 2^{-23}。  
  
根据以上信息，我们可以计算出32位浮点数能表示的最大正数：  
  
最大正数 = (1 + 尾数部分最大值) * 2^{最大指数}  
  
最大正数 = (1 + (1 - 2^{-23})) * 2^{127}  
  
最大正数 ≈ 3.4028235 * 10^{38}

# 设计模式

装饰器模式在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责（方法或属性）

# map 和 unordered_map区别


  
map 
底层采用**红黑树**实现，红黑树具有自动排序的功能，因此 map 内部的所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素。对于 map 进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。 
unordered_map
unordered_map 内部实现了一个**哈希表**，其元素的排列顺序是无序的。

map
   
优点：有序性，其元素的**有序性**在很多应用中都会简化很多的操作；底层适用红黑树实现，因此效率非常的高  
缺点： 空间占用率高，因为 map 内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间
适用场景：对于那些有顺序要求的问题，用 map 会更高效一些

unordered_map  
优点： 内部实现了哈希表，因此其**查找速度非常的快**  
缺点： 哈希表的建立比较耗费时间  
适用处：对于查找问题，unordered_map 会更加高效一些