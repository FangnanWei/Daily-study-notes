# 子带滤波器

![image](https://cdn.staticaly.com/gh/andyye1999/image-hosting@master/20221206/image.jf3zp1ztg4g.webp)

(1) 将输入信号分帧，帧长为160，对分帧后的信号加等长的汉明窗，加窗后的信号通入缓存区，缓存区的长度是原型低通滤波器的阶数。

(2) 原型低通滤波器经过频带搬移得到320个子带滤波器，加窗后的信号通过子带滤波器，再经过类似快速傅里叶变换的加权求和得到320个子带信号，根据实数序列快速傅里叶变换的共轭对称性，只需输出前160个子带信号即可进行后续的算法处理。

每新到一个采样点都进行一次卷积运算，但是后面的抽取过程会丢弃一个点，表明每两次卷积运算就有一次是无用的，因此可以将抽取和滤波调换位置，先进行下采样抽取，再进行卷积滤波。后面的综合过程也是同样的道理，可以将插值和滤波调换位置，让滤波操作在低速率端进行。

```cpp
for (j = 0; j < ORD2; j++)
        prototype_filter[j] = (Float32)(0.54 - 0.46 * cos((2.0 * j + 1) / ORD2)) * (Float32)sin(PI * (2 * j - ORD2 + 1) / (4 * D)) / (Float32)(PI * (2 * j - ORD2 + 1) / 2.0);
    for (k = 0; k < D; k++)
    {
        for (j = 0; j < 2 * D; j++)
        {
            cos_tab0[k][j] = (Float32)cos(2 * PI * k * j / (2 * D));
        }
        for (j = 0; j < 2 * D; j++)
        {
            sin_tab0[k][j] = (Float32)sin(2 * PI * k * j / (2 * D));
        }
    }
    for (i = 0; i < 2 * D; i++)
    {
        for (acc2 = 0.0f, j = 0; j < ORD2 / (2 * D); j++)
            acc2 += st->buf_spk[j * 2 * D + i] * prototype_filter[j * 2 * D + i];
        tmp[2 * D - 1 - i] = acc2;
    }
    for (k = 0; k < D; k++)
    {
        for (acc2 = 0.0f, j = 0; j < 2 * D; j++)
            acc2 += tmp[j] * cos_tab0[k][j];
        st->spk_ana_re[k][ORD3 - 1] = acc2;
        for (acc3 = 0.0f, j = 0; j < 2 * D; j++)
            acc3 += tmp[j] * sin_tab0[k][j];
        st->spk_ana_im[k][ORD3 - 1] = acc3;
    }
```

![IMG_4291(12-07-14-17-47)](https://cdn.staticaly.com/gh/andyye1999/image-hosting@master/20221207/IMG_4291(12-07-14-17-47).51de4tojvf.webp)

