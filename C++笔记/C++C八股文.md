## 1.C基础

### 1.include头文件的顺序以及双引号""和尖括号<>的区别

尖括号<>：是到系统库文件目录中寻找头文件，一般是**系统文件**；

双引号""：是到当前文件目录中寻找头文件，一般是**自定义文件**；

### 2.简述C++/C从代码到可执行二进制文件的过程

C++和C语言类似，一个C++程序从源码到执行文件，有四个过程，**预编译、编译、汇编、链接**。

1. 预编译：这个过程主要的处理操作如下：

   （1） 将所有的#define删除，并且展开所有的宏定义

   （2） 处理所有的条件预编译指令，如#if、#ifdef

   （3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。

   （4） 过滤所有的注释

   （5） 添加行号和文件名标识。

2. 编译：这个过程主要的处理操作如下：

   （1） 词法分析：将源代码的字符序列分割成一系列的记号。

   （2） 语法分析：对记号进行语法分析，产生语法树。

   （3） 语义分析：判断表达式是否有意义。

   （4） 代码优化：

   （5） 目标代码生成：生成汇编代码。

   （6） 目标代码优化：

3. 汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。

4. 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。

   链接分为静态链接和动态链接。

   静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。

   而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。

### 3.static关键字的作用

**定义全局静态变量和局部静态变量**：初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。

**全局静态变量**：全局静态变量只能在本文件中使用；

**局部静态变量**：局部静态变量在作用域结束时，并没有销毁，仍然驻留在内存当中，当函数再次被调用时，值不变；

**定义静态函数**：静态函数只能在本文件中使用；

**C++定义类内静态成员变量**：类内静态成员是类的所有对象共享的成员，而不是某个对象的成员，静态成员只存储一处，供所有对象共用；

**C++类内静态成员函数**：静态成员函数不是某个对象的成员，对静态成员函数的引用不需要用对象名；静态成员函数的实现不能直接引用类内的非静态成员，可以引用类中说明的静态成员；若要引用非静态成员，需要通过对象来引用。

### 4.字符串char* s 与char s[] 的区别

- char \*s 只是一个保存字符串首地址的指针变量；char a[ ] 是许多连续的内存单元。
- 在声明时，char *s=“hello”声明了一个字符串常量，其内容不能被修改；在声明时，char s[]=“hello”声明了一个字符串变量，其内容能被修改。
- 数组名可以赋值给指针表示地址；指针不能赋值给数组名。
- char*是一个指针变量，值（指向）是可以改的，只能指向（字符串）常量，指向的区域的内容不可改变；char s[]是一个指针常量，值（指向）不能变，但指向的目标的内容是可变的。
- 当定义 char a[10 ] 时，编译器会给数组分配十个字符类型的单元；而定义 char \*s 时， 这是个指针变量，只占八个字节（64位），用来保存一个地址。

### 5.链表和数组有什么区别

- 数组是一块连续的空间，声明时就要确定长度；链表是一块可不连续的动态空间，长度可变，每个结点要保存相邻结点指针。链表是链式的存储结构；数组是顺序的存储结构。
- 链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储。
- 链表的插入删除元素相对数组较为简单，不需要移动元素，但是寻找某个元素较为困难；插入和删除是O(1)，读取上是O(n)。
- 数组寻找某个元素较为简单，但插入与删除比较复杂，由于最大长度需开始时指定，达到最大长度时，扩充长度不如链表方便。插入和删除是O(n)，读取上是O(1)。

### 6.什么是函数指针，如何定义函数指针，有什么使用场景

**概念：**函数指针就是**指向函数**的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。

**定义**形式如下：

```c++
int func(int a);  
int (*f)(int a);  
f = &func;\\f = func;
x = (*fun)();\\x = fun();
```

**应用场景**：**回调**（callback）。如果别人的库里面调用我们的函数，就叫Callback。如qsort函数需要调用自定义的比较函数进行排序。

**指针函数和函数指针的区别**：

定义不同

指针函数本质是一个函数，其返回值为指针。
函数指针本质是一个指针，其指向一个函数。

写法不同

指针函数：int* fun(int x,int y);
函数指针：int (*fun)(int x,int y);



### 7.什么是野指针，怎么产生的，如何避免？

**概念：**野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）

**产生原因**：释放内存后指针不及时置空（野指针）；指针未初始化使用；指针越界访问。

**避免办法：**

（1）初始化置NULL

（2）指针使用之前判断有效性

（3）小心指针越界

（4）指针释放后置NULL

（5）使用智能指针

### 8.内联函数和宏函数的区别，内联函数与函数区别

内联函数和宏函数区别：

- **宏定义不是函数**，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；**而内联函数本质上是一个函数**，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。
- **宏函数**是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；**而内联函数**则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率
- **宏定义**是没有类型检查的，无论对还是错都是直接替换；**而内联函数**在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等

内联函数与函数区别：

- 内联函数比普通函数多了关键字**inline**
- 内联函数避免了函数调用的**开销**；普通函数有调用的开销
- 普通函数在被调用的时候，需要**寻址（函数入口地址）**；内联函数不需要寻址。
- 内联函数有一定的限制，内联函数体要求**代码简单**，不能包含复杂的结构控制语句；普通函数没有这个要求。

注意点：

- 使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性
- 在内联函数内不允许用循环语句和开关语句。 如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。
- 同其它函数不同的是，最好将inline函数定义在头文件，而不仅仅是声明，因为编译器在处理inline函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。

### 9.运算符i++和++i的区别

**赋值顺序不同**：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。

**效率不同**：后置++执行速度比前置的慢。

**i++ 不能作为左值，而++i 可以**：

两者都不是原子操作。

### 10.new和malloc的区别，各自底层实现原理

区别：

- new是操作符，而malloc是函数。
- new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。
- malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。
- new可以被重载；malloc不行
- new分配内存更直接和安全。
- new发生错误抛出异常，malloc返回null

底层原理：

**malloc底层实现：**当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。

**new底层实现：**关键字new在调用构造函数的时候实际上进行了如下的几个步骤：

1. 创建一个新的对象
2. 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）
3. 执行构造函数中的代码（为这个新对象添加属性）
4. 返回新对象

### 11.const和define的区别，typedef和define的区别。

const用于定义常量；而define用于定义宏，而宏也可以用于定义常量。都用于常量定义时，它们的区别有：

- const生效于编译的阶段；define生效于预处理阶段。
- const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。
- const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。

typedef和define的区别：

- 用法不同：typedef用来定义一种数据类型的别名，增强程序的可读性；define主要用来定义常量，以及复杂使用频繁的宏。
- 执行时间不同：typedef是编译过程的一部分，有类型检查的功能；define是宏定义，是预编译的部分，只是简单的进行字符串的替换，不进行类型的检查。
- 作用域不同：typedef有作用域限定；define不受作用域约束，只要是在define声明后的引用都是正确的。
- typedef定义的是语句，句尾加分号；define不是语句，句尾不需要加分号。
- 修饰指针作用不同：
  - typedef定义的指针：p不可更改，p指向的内容可以更改，相当于 int \* const p；指针常量
  - define定义的指针：p可以更改，p指向的内容不可以更改，相当于 const int \* p；常量指针

### 12.指针常量与常量指针

```C
const int a;     //指的是a是一个常量，不允许修改。
const int *a;    //a指针所指向的内存里的值不变，即（*a）不变
int const *a;    //a指针所指向的内存里的值不变，即（*a）不变//常量指针
int *const a;    //a指针所指向的内存地址不变，即a不变//指针常量
const int *const a;   //都不变，即（*a）不变，a也不变
```

### 13.堆和栈的区别

**堆栈空间分配不同**：栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。

**堆栈缓存方式不同**：栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。

**堆栈数据结构不同**：堆类似数组结构；栈类似栈结构，先进后出。

### 14.C++内存管理

一个程序占用的内存通常分为以下几个部分：**代码区、常量区、全局（静态）存储区、堆区、栈区**

- 代码区：存放程序编译后的二进制代码。【代码】
- 常量区：存放只读变量和字符串常量，一经初始化，不可修改。【const变量、字符串】
- 全局（静态）存储区：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在.data段区域，编译时分配内存空间；未初始化或初始化为0的全局和静态变量在.bss段区域，编译时不会分配空间。
- 堆区：由程序员手动申请/释放，若不手动释放，程序结束后由系统回收。【malloc申请的内存】
- 栈区：由系统自动分配/释放，存放函数参数，局部变量等。【局部变量、函数参数】

### 15.内存模型介绍

![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788035619/FC055373B87370BDAA91631459B38E30)

**data段**：存放程序中已初始化的全局变量和静态变量的一块内存区域。

**BSS段**：  存放程序中未初始化的全局变量和静态变量的一块内存区域。

**代码段：**存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。

**堆区：**动态申请内存用。堆从低地址向高地址增长。由new分配的内存块。

**栈区：**存储局部变量、函数参数值。栈从高地址向低地址增长，是一块连续的空间。由编译器分配。

### 16.二进制可执行文件分为几部分

- 一个可执行二进制程序没有调入到内存运行时：可执行二进制程序 = 代码段(.text)＋初始化数据段(.data)+未初始化数据段(.bss)

- 当程序被加载到内存单元时：正在运行的C程序 = 代码段(.text)+初始化数据段(.data)+未初始化数据段(.bss)+堆(.heap)+栈（.stack）

- 在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并将在内存中为这些段分配空间。栈亦由操作系统分配和管理，而不需要程序员显示地管理；堆段由程序员自己管理，即显示地申请和释放空间。

- 动态分配与静态分配:

  - 编译时执行静态分配，就已经决定好了分配多少Text+Data+BSS+Stack，在运行时执行动态分配。

  - 通过malloc()动态分配的内存，需要程序员手工调用free()释放内存，否则容易导致内存泄露，而静态分配的内存则在进程执行结束后系统释放(Text,Data), 但Stack段中的数据很短暂，函数退出立即被销毁。

### 17.什么是内存泄露，内存泄露怎么检测

内存泄漏：

内存泄漏指的是内存被分配出去后，使用完毕没有被释放，导致这部分内存无法被再次使用，造成系统内存的浪费，严重的话可能会导致程序运行速度减慢甚至系统崩溃等。

（1）new和malloc申请资源使用后，没有用delete和free释放；

（2）子类继承父类时，父类析构函数不是虚函数。

（3）Windows句柄资源使用后没有释放。

内存泄漏检测：

（1）使用了内存分配的函数，一旦使用完毕，要记得使用其相应的函数释放掉。

（2）将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。

（3）使用智能指针。

（4）一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。

### 18.内存对齐

内存对齐应用于三种数据类型中：**struct/class/union**

struct/class/union内存对齐原则有四个：

- 数据成员对齐规则：第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。
- 收尾工作：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的"最宽基本类型成员"的整数倍，不足的要补齐。(基本类型不包括struct/class/uinon)。
- 结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储。(struct a里存有struct b，b里有char,int ,double等元素，那b应该从8的整数倍开始存储)。
- sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。

**意义**：经过内存对齐之后，CPU的内存访问速度大大提升；适应部分平台，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常；

### 19.sizeof()函数和strlen()函数的区别

- sizeof是一个操作符；strlen是一个库函数。
- sizeof的参数可以是数据的类型，也可以是变量；strlen只能是以结尾为'\0'的字符串做参数。
- sizeof的结果编译器在编译的时候就计算出来了；strlen函数需要在运行时才能计算出来。
- sizeof计算的是数据类型占的内存的大小；strlen是计算字符串实际的长度（不包含'\0'）。
- sizeof传入数组时输出为指针的内存大小；strlen传入数组时输出数组中字符串的大小。


```c
char *str1 ="abcde";
char str2[] = "abcde";
char str3[8] = {'a'};
sizeof(str1) = 4;strlen(str1) = 5;//sizeof输出指针的大小，strlen输出字符串大小（不包含'\0'）
sizeof(str2) = 6;strlen(str2) = 5;//sizeof输出数组的大小，strlen输出字符串大小（不包含'\0'）
sizeof(str3) = 8;strlen(str3) = 1;//sizeof输出数组的大小，strlen输出字符串大小
```

### 20.strcpy、sprintf、memcpy的区别

- 操作对象不同：strcpy操作对象是字符串；sprintf操作对象是源对象是多种数据类型，目标对象是字符串；memcpy操作对象是两个任意可操作的内存地址，并不限于何种数据类型。
- 执行效率不同：memcpy最高、strcpy次之、sprintf效率最低。
- 实现功能不同：strcpy主要实现字符串变量间的拷贝，sprintf主要实现其他数据类型格式到字符串的转化，memcpy主要是内存块间的拷贝。

### 21.各种排序算法的时间复杂度

|   排序算法   | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |
| :----------: | :------------: | :------------: | :--------: | :------: |
| 直接插入排序 |     O(n^2)     |     O(n^2)     |    O(1)    |    是    |
|   希尔排序   |    O(nlogn)    |     O(n^s)     |    O(1)    |   不是   |
| 直接选择排序 |     O(n^2)     |     O(n^2)     |    O(1)    |   不是   |
|    堆排序    |    O(nlogn)    |    O(nlogn)    |    O(1)    |   不是   |
|   冒泡排序   |     O(n^2)     |     O(n^2)     |    O(1)    |    是    |
|   快速排序   |    O(nlogn)    |     O(n^2)     |  O(logn)   |   不是   |
|   归并排序   |    O(nlogn)    |    O(nlogn)    |    O(n)    |    是    |
|    桶排序    |                |                |            |          |

### 22.一个浮点数默认是float型还是double型

- 小数在C语言中默认是double类型
- float属于单精度型浮点数据，double属于双精度型浮点数据。float占4个字节内存空间，而double占8个字节。
- float只能提供6位有效数字，一般来说绝对6位，可能7为应该是6~7位，double可提供16位有效数字。%.8f的意思是输出小数点后八位，float不足八位会输出0；
- CPU处理单精度浮点数的速度比处理双精度浮点数快，如果不声明，默认小数为double类型，所以如果要用float的话，必须进行强转，eg：float a = 1.24546f;

































## 2.C++基础

### 1.C++中 struct 和 class 的区别

- struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装；
- struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的；
- class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数；

### 2.nullptr调用成员函数可以吗？为什么？

能，因为在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。

### 3.引用和指针有什么区别

- 引用必须被初始化，但是不分配存储空间。指针可不被初始化（但最好初始化），在初始化时需要分配存储空间。
- 引用初始化以后不能被改变，指针可以改变所指的对象。
- 不存在指向空值的引用，但是存在指向空值的指针。
- 对引用使用“sizeof”得到的是变量的大小，对指针使用“sizeof”得到的是变量的地址的大小。
- 理论上指针的级数没有限制，但引用只有一级。即不存在引用的引用，但可以有指针的指针。

### 4.哈希冲突怎么解决

（1）**链地址法**：对于哈希值，使用链表进行连接

优点：处理冲突简单，无堆积现象；适合总数经常变化的情况；占空间小；删除结点的操作易于实现，只要简单地删去链表上相应的结点即可。

缺点：查询时效率较低；不容易序列化。

（2）**再哈希法**：提供多个哈希函数，如果第一个哈希函数计算出来的key的哈希值冲突了，则使用第二个哈希函数计算key的哈希值。

优点：不易产生聚集。

缺点：增加了计算时间。

（3）**建立公共溢出区**：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。

（4）**开放地址法**：当关键字key的哈希地址p = H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，若p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。分为线性探测法、二次平方探测、伪随机数探测；

优点：容易序列化；

缺点：占用空间大；删除节点麻烦；











## 3.C和C++对比

### 1.C++和C的区别

- C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多**新特性**，如引用、智能指针、auto变量等。
- C++是**面对对象**的编程语言；C语言是**面对过程**的编程语言。
- C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来**改善安全性**，如const常量、引用、cast转换、智能指针、try—catch等等；
- C++支持范式编程，如模板类、函数模板。

### 2.C++结构体和C结构体的区别

- C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数。
- C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种。
- C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。
- C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用。

### 3.导入C函数的关键字是什么，C++编译时和C有什么不同？

- 关键字：在C++中，导入C函数的关键字是**extern**，表达形式为**extern “C”**， extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。
- 编译区别：由于C++支持函数重载，因此编译器编译函数的过程中会将函数的**参数类型**也加到编译后的代码中，而不仅仅是**函数名**；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名

