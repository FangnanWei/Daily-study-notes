#  [Overlap-add & Overlap-save method](https://zhuanlan.zhihu.com/p/480320394)    
利用圆周卷积与线性卷积的关系，在频域通过FFT是快速计算卷积的方法之一。但当参与卷积的序列长度相差较多，如常见的音频系统，输入序列通常是麦克风拾取到的数据，输入序列长度会很长，此时需要对另外一个序列补较多的零再进行计算，计算效率通常很低，同时还会引入较长的处理延时。为了利用快速卷积法的优越性，可将较长的输入序列x（n）进行分段，再通过频域FFT快速卷积算法得到子序列的卷积结果，最后按照相应的规则将子序列的卷积结果拼接起来，就可以得到最终的线性卷积结果。一般按照分段的规则可以将上述方法分为两类，即OLA和OLS。
## OLA  
![image](https://raw.githubusercontent.com/andyye1999/image-hosting/master/20220524/image.6k0dk95c2b40.webp)   
### STFT的OLA
先做ISTFT（短时傅里叶反变换），得到256点的实数值。这256点包括上一帧的尾部的96点，即有重叠。该怎么拼接保证声音连贯呢？上面讲从时域到频域变换时用的窗是汉宁矩形混合窗，汉宁窗前半部分（头部96点）类似于做正弦操作，后半部分（尾部96点）类似于做余弦操作。重叠部分是在上一帧的尾部，加窗做的是类余弦操作，在当前帧是头部，加窗做的是类正弦操作。信号重建叠加时一般要求能量或者幅值不变，能量是幅值的平方。那些重叠的点（假设幅值为m）在上一帧中加窗时做了类余弦操作，加窗后幅值变成了m*cosθ，在当前帧中加窗时做了类正弦操作，加窗后幅值变成了m*sinθ，能量和为m2*cos2θ + m2*sin2θ, 正好等于m2(原信号的能量)，这说明只要把重叠部分相加就可以保证语音信号的连贯了。这就解释了代码中把ISTFT后的值再做一次加窗操作并把重叠部分相加的原因。做完ISTFT后有256点数据，当前帧的头部96点数据与上一帧的尾部96点数据相加，中间64点数据不变，当前帧尾部96点数据与下一帧的头部96点数据相加，这样就能很好的拼接处连贯的语音数据了。
![](https://img2020.cnblogs.com/blog/1181527/202110/1181527-20211021224607997-774155967.jpg)
## OLS  
![image](https://raw.githubusercontent.com/andyye1999/image-hosting/master/20220524/image.4o7qzb51tdk0.webp)  
与OLA不同的是，OLS选取的分割长度为L+M-1
然后丢弃其前M-1点，保留剩余L点的数值

