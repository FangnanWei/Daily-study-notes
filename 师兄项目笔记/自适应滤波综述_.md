## 1.算法类型

参考网址：[](https://www.cnblogs.com/LXP-Never/p/11773190.html)

### 1.自适应滤波器类型

（1）非线性自适应滤波器：包括基于神经网络的自适应滤波器及Volterra滤波器，**处理能力更强**。

（2）线性自适应滤波器：**计算复杂度较低**，所以实践中，线性自适应滤波器使用较多。

### 2.FIR与IIR滤波器

（1）FIR滤波器时非递归系统：即当前输出样本仅是过去和现在输入样本的函数，其系统冲激响应h(n)是一个有限长序列。具有很好的线性相位，无相位失真，**稳定性较好**。

（2）IIR滤波器时递归系统：即当前输出样本是过去输出和过去输入样本的函数，其系统冲激h(n)是一个无限长序列。IIR系统的相频特性是非线性的，稳定性不能保证。好处是实现阶数较低，**计算量较少**。

### 3.自适应滤波器算法对比

自适应滤波器算法按照不同的优化准则，常见自适应滤波算法有：递推最小二乘算法(RLS)，最小均方误差算法(LMS)，归一化均方误差算法(NLMS)，快速精确最小均方误差算法，子带滤波，频域的自适应滤波等等。

#### 1.谱减法

谱减法根据噪声的加性特点，通过噪声能量估计和增益计算得到噪声的功率谱，然后从带噪语音的功率谱中减去估计出的噪声得到较为纯净的语音。

由于谱减法没有考虑人耳听觉对语音频谱分布的幅度较为敏感的特点。因此采用谱减法进行滤波后，会给原信号带来噪声，使语音质量变差，并且会影响到其他处理，如语音编码等。

## 2.算法详细介绍

### 1. LMS算法

#### 1. LMS算法框图

LMS是最广泛应用的自适应滤波算法，以MSE误差为目标函数，以梯度下降为优化算法。并且通常情况下，LMS以最新的输入计算的瞬时梯度替代实际梯度计算，类似于机器学习的随机梯度下降法。

NLMS是使用输入的功率对步长进行归一化的方法，可以取得更好的收敛性能。

![img](https://gitee.com/qian-mi/typora_picture/raw/master/img/202209201359185.jpeg)

#### 2. LMS算法推导

x(n): 输入信号
w(n): 自适应滤波器的系统函数
y(n): 通过滤波器的输出信号
d(n): 期望信号(也成为导师信号，监督信号，理想信号)
e(n): 误差信号

输出信号y(n) = x(n)*w(n)，误差信号e(n) = d(n) - y(n)。均方误差为J = E[e^2(n)]。目标是使得均方误差最小，对于维纳滤波，使J对于w(n)的偏导等于0，找出解析解。
$$
\cfrac{\delta J}{\delta w} = E[2e(n)\cfrac{\delta e}{\delta w}] = E[2e(n)\cfrac{\delta \{d(n) - x(n)*w(n)\}}{\delta w(n)}] = -2E[e(n)x(n-i)] =-2e(n)x(n-i)\\
w(n+1) = w(n) + 2\mu e(n)x(n-i)
$$

#### 3. LMS算法步长 $\mu$ 的分析

$$
E[e(n)x(n-i)] = E\{[d(n) - \sum_{k=0}^{M-1}w(n)x(n-k)]x(n-i)\}=-2r_{xd}+2\sum_{k=0}^{M-1}w(k)r_{xx}(i-k)
$$

令 $\Gamma = r_{xx}(i-k)$ ，为x(n)的自相关矩阵，$\overrightarrow{w}$ 为w(n)的向量，$r_{xd}$ 是x(n)和d(n)的互相关，所以
$$
w(n+1) =w(n) +2\mu e(n)x(n-i) = w(n) + 2\mu (r_{xd} - \Gamma \overrightarrow{w})=(I-2\mu \Gamma)\overrightarrow{w}+2\mu r_{xd}\\
\overrightarrow{w}^0(n+1) = \overrightarrow{w}(n)^0(I-2\mu \Lambda)+2\mu r_{xd}
$$
其中，令$\Gamma = U\Lambda U^T,\overrightarrow{w}^0(n)=U^T,r_{xd}=U^Tr_{xd}$ ，若保证其次方程有解，第k个方程为
$$
\overrightarrow{w}^0(k,n) = c(I-2\mu \lambda _k)^nu(n),~~~~~~~~~~~~~~~k = 0,1,...,M-1
$$
为了保证收敛，应保证 $|I-2\mu\lambda_k|<1$ ,

则 $\mu$ 为
$$
0<\mu<\cfrac{1}{\lambda_{max}}
$$

#### 4.LMS优缺点

**优点**：算法简单，易于实现，算法复杂度低(LMS<RLS)，能够抑制旁瓣效应

**缺点**：

- 收敛速率较慢(LMS<RLS)，因为LMS滤波器系数更新是逐点的（每来一个新的$x(n)$和$d(n)$，滤波器系数就更新一次）,每一次采样点梯度的估计对于真实梯度会存在误差，导致滤波器系数的每次更新不会严格按照真实梯度方向更新，而是有一定的偏差
- 跟踪性能较差，并且随着滤波器阶数(步长参数)升高，系统的稳定性下降
- LMS要求不同时刻的输入向量$x(n)$线性无关——LMS 的独立性假设。如果输入信号存在相关性，会导致前一次迭代产生的梯度噪声传播到下一次迭代，造成误差的反复传播，收敛速度变慢，跟踪性能变差。

### 2. NLMS算法

#### 1.NLMS算法介绍

归一化最小均方(Normalized Least Mean Squares，NLMS)算法是改进的LMS算法，对于较大的输入，会导致梯度噪声的放大，因此需要用输入向量的平方范数进行归一化。根据原LMS算法中误差信号与远端输入信号的乘积，对远端输入信号的平方(功率)进行归一化处理，将固定步长因子的LMS算法变为根据输入信号时变的变步长NLMS算法，具体算法如下：
$$
w(n+1) = w(n) + \cfrac{\mu}{x^T(n)x(n)+\phi}e(n)x(n-i)
$$

#### 2.NLMS推导

参考链接：https://blog.csdn.net/wjrenxinlei/article/details/62892008

NLMS 算法的设计准则可以表述为带约束的优化问题：给定抽头输入向量x(n)和期望信号d(n)，确定更新后的权重向量h(n+1)，使以下式的平方范数最小：
$$
\begin{cases}
min:\delta h(n+1) = h(n+1) - h(n)\\
st:h(n+1)x(n)=d(n)
\end{cases}
$$
可以使用拉格朗日乘子法解决该带约束的优化问题，可得：
$$
J(n) = ||\delta h(n+1)||^2 + \lambda (d(n)-h^T(n+1)x(n))\\
h(n+1) = h(n) + \cfrac{1}{2}\lambda x(n)\\
d(n) = h^T(n)x(n) + \cfrac{1}{2}\lambda ||x(n)||^2\\
\lambda = \cfrac{2e(n)}{||x(n)||^2}\\
h(n+1) = h(n) + \cfrac{e(n)}{||x(n)||^2}x(n)
$$

#### 3.NLMS优缺点

- **优点**：改善了LMS算法收敛速度慢的缺点。计算简单、更高的精度
- **缺点**：输入相关信号时，收敛速率明显下降

#### 4.算法复杂度计算

<img src="https://gitee.com/qian-mi/typora_picture/raw/master/img/202209201359937.webp" alt="img" style="zoom:80%;" />

<img src="https://gitee.com/qian-mi/typora_picture/raw/master/img/202209201400012.webp" alt="img" style="zoom: 80%;" />

<img src="https://gitee.com/qian-mi/typora_picture/raw/master/img/202209201403457.jpg" alt="202209201359605" style="zoom:80%;" />

在评价算法复杂度的时候，乘法的最高次幂才是最重要的，所以说LMS算法复杂度O(N)，RLS是O(N^2^)，NLMS是O(N)。此外矩阵求逆复杂度是O(N^3^)，迭代运算防止了矩阵求逆的过程，所以RLS的复杂度为O(N^2^)。

### 3. FxLMS算法

#### 1. FxLMS算法框图

为了考虑次要路径传递函数 H (z) 的影响，需要修改传统的最小均方 (LMS) 算法。为了确保算法的收敛，误差相关器的输入由辅助路径估计值 C(z) 过滤。这导致了 Morgan 开发的过滤 X LMS (FXLMS) 算法。Burgess 建议使用这种 FXLMS 算法来补偿 ANC 应用中辅助路径的影响。

![img](http://www.geocities.ws/ranjit_raphael/fig7.jpg)

#### 2. FxLMS算法推导

h(n): 实际次级路径参数
c(n): 模拟次级路径参数，进行滤波x信号
y(n): 通过滤波器的输出信号
y'(n):输出信号实际次级路径后的信号，即到达误差麦克风的信号
e(n): 误差信号

输出信号y‘(n) = x(n)\*w(n)\*h(n)，误差信号e(n) = d(n) - y'(n)。均方误差为J = E[e^2(n)]。目标是使得均方误差最小，对于维纳滤波，使J对于w(n)的偏导等于0，找出解析解。
$$
\cfrac{\delta J}{\delta w} = E[2e(n)\cfrac{\delta e}{\delta w}] = E[2e(n)\cfrac{\delta \{d(n) - x(n)*w(n)*h(n)\}}{\delta w(n)}] =-2e(n)x(n-i)h(n)\\
xf(n) = x(n)*h(n)\\
w(n+1) = w(n) + \cfrac{\mu}{xf^T(n)xf(n)+\phi} e(n)xf(n-i)
$$

#### 3. Modified FxLMS算法

该方法为ADAU1467硬件使用的降噪方法，实现了 Modified Filtered-X LMS 算法，它是一种基于最小化误差信号的最小均方值的自适应 FIR 滤波器。该算法应用于噪声消除应用，其中考虑到消除点不在反向噪声输出的扬声器，而是在误差麦克风的位置。该模块提供了一种训练模式，可以训练和估计输出扬声器和误差麦克风之间的次要路径作为 FIR 滤波器系数。然后在模块的运行时模式中使用这些系数，以考虑路径并根据参考输入提供有效的噪声消除。

![img](https://wiki.analog.com/_media/resources/tools-software/sigmastudio/toolbox/filters/mfxlms-block_diagram.png?w=700&tok=1f2d24)

- **P(z)**是要建模的系统（噪声源）
- **S(z)**是声域中的次要路径
- **W'(z)**是 LMS 滤波器
- **S'(z)**是建模的次要路径
- **x(n)**是参考输入
- **d(n)**是声域中的噪声信号
- **e(n)**是声域内噪声和抗噪声信号相消干涉后的残余信号
- **y(n)**是用 LMS 系数过滤参考输入的输出
- **yf(n)**是使用二级路径滤波器系数对 y(n) 进行滤波后的输出
- **xf(n)**是使用二级路径滤波器系数对 x(n) 进行滤波后的输出
- **y'(n)**是用 LMS 系数过滤 xf(n) 的输出
- **e(n)**是 LMS 系统的总误差反馈，计算公式为 e(n) = error+ yf(n)- y'(n)

更新公式为：
$$
w(n+1) = w(n)+\cfrac{\mu}{xf^T(n)xf(n)+\phi} e(n)xf(n-i)
$$

### 4. 递归最小二乘法(RLS)

​		MMSE适合处理平稳序列，因为MMSE是一个均匀加权的最优化问题，也就是说，每一时刻的误差信号对目标函数的贡献权重是相同的，如果对于非平稳的语音信号效果就不太好了。

#### 1.RLS推导

RLS重新定义了目标函数：
$$
J(w) = \sum_{i=1}^n\lambda^{n-i}|e(i)|^2=\sum_{i=1}^n\lambda^{n-i}[d(i)-H^T(i)X(i)]^2\\
=\sum_{i=1}^n\lambda^{n-i}d^2(i)-2H^T(n)\sum_{i=1}^n\lambda^{n-i}d(i)X(i)+H^T(n)[\sum_{i=1}^n\lambda^{n-i}X(i)X^T(i)]H(n)
$$
　　$\lambda$称为遗忘因子($0<\lambda\leq 1$)。对离$n$时刻越近的误差加比较大的权重，遗忘越少，而对离$n$时刻越远的误差加比较小的权重，遗忘越多

- $\lambda=1$：无任何遗忘功能，此时 RLS 退化为 LMS 方法 

定义式子：
$$
P(n)=\sum_{i=1}^n\lambda^{n-i}d(i)X(i)\\
R(n)=\sum_{i=1}^n\lambda^{n-i}X(i)X^T(i)\\
\cfrac{\delta J}{\delta w} = -2P(n)+2R(n)H(n)=0\\
H(n) = R^{-1}(n)P(n)
$$
简化算法，写成递推形式
$$
P(n)=\lambda P(n-1)+d(n)X(n)\\
R(n)=\lambda R(n-1)+X(n)X^T(n)
$$
根据矩阵求逆引理可得：
$$
R^{-1}(n)=\lambda^{-1} R^{-1}(n-1)-\lambda^{-1}g(n)X^T(n)R^{-1}(n-1)\\
g(n) = \cfrac{R^{-1}(n-1)X(n)}{\lambda+X^T(n)R^{-1}(n-1)X(n)}\\
R^{-1}(n)X(n) = g(n)
$$
将p(n)和上述式子带入求H(n)
$$
\alpha(n)=d(n)-H^T(n-1)X(n)\\
H(n)=H(n-1)+g(n)\alpha(n)
$$

#### 2.RLS执行流程步骤

$$
g(n) = \cfrac{R^{-1}(n-1)X(n)}{\lambda+X^T(n)R^{-1}(n-1)X(n)}\\
\alpha(n)=d(n)-H^T(n-1)X(n)\\
H(n)=H(n-1)+g(n)\alpha(n)\\
R^{-1}(n)=\lambda^{-1} R^{-1}(n-1)-\lambda^{-1}g(n)X^T(n)R^{-1}(n-1)\\
e(n)=d(n)-H^T(n)X(n)
$$

#### 3.RLS优缺点

- **优点**：RLS自适应滤波器提供更快的收敛速度和跟踪性能。
- **缺点**：由于RLS 使用了自相关矩阵的逆矩阵的递推，所以，一旦输入信号的自相关矩阵接近奇异时RLS 的收敛速度和跟踪性能会严重恶化 。

### 5.AP算法

#### 1. 线性方程组相关知识补充

对于线性方程组：$A_{m*n}X_{n*1}=B_{m*1}$

考虑（行/列）满秩的情况，分下面三种情况：

（一）如果$m=n$，则：
$$
x=A^{-1}b~~~~~~~~~唯一解 精确解
$$
（二）如果$m<n$即方程的个数小于未知数的个数 此时方程组有无穷多个解 。 为了得到唯一解 必须增加约束条件 要求 x 的范数最小 这样得到的解称为最小范数解 。
$$
x=A^H(AAH)^{-1}b~~~~~~~~~最小范数解
$$
（三）如果$m>n$即方程的个数大于未知数的个数 此时方程组不存在精确解 只存在近似解 。 我们自然希望找到一个使方程组两边的误差平方和为最小的解 即最小二乘解 。
$$
x=(A^HA)^{-1}A^Hb
$$

#### 2.AP算法推导

仿射投影算法 (Affine projection algorithm) 是运算量介于 LMS 和 RLS 之间的一种自适应算法 。
$$
y(n)=w^H(n)x(n)=X^T(n)w^∗(n)
$$
其中，$X(n)$是输入向量矩阵，$w^*(n)$是$w(n)$的共轭转 置

权重更新方程：$w(n)=w(n-1)+\mu \Delta w_{n}$

滤波器输出：$y(n)=X^{T}(n) w^{*}(n-1)+\mu X^{T}(n) \Delta w_{n}^{*}$

令滤波器的实际输出作为期望输出$d(n)$，则先验误差向量表示为：$e(n)=y(n)-X^{T}(n) w^{*}(n-1)$

为了简化，我们令$\mu =1$，则：
$$
X^T(n)\Delta w_n^*=e(n)\\
X^H(n)\Delta w_n=e^*(n)
$$
我们发现 滤波器系数的更新量$\Delta w^{*}_n(\Delta w_n)$，是由$L$个线性方程组成的线性方程组决定的，利用线性方程组的结论，重新讨论

（1）$1\leq L< N$，方程组为欠定方程，具有唯一的最小范数解
$$
\Delta w_n=X(n)(X^H(n)X(n))^{-1}e^*(n)
$$
此时，权重更新公式变为：
$$
w(n)=w(n-1)+\mu X(n)(X^H(n)X(n))^{-1}e^*(n)
$$
如果$L=1$，则退化为 NLMS 算法：
$$
w(n)=w(n-1)+\mu \cfrac{x(n)}{(x^H(n)x(n))^{-1}}e^*(n)
$$
实际中，L取2、3就足够了

（2）$L\geq N$，方程组为超定方程，其唯一解为最小二乘解：
$$
\Delta w_n=(X(n)X^H(n))^{-1}X(n))e^*(n)
$$
此时，权重更新公式变为：
$$
w(n)=w(n-1)+\mu(X(n)X^H(n))^{-1}X(n)e^*(n)
$$
如果我们令：$\mu =1$, $R(n)=\frac{1}{L}X(n)X^H(n)$, $r(n)=\frac{1}{L}X(n)y^*(n)$并结合公式17，可得
$$
w(n)=w(n-1)+(X(n)X^H(n))^{-1}X(n)(y^*(n)-X^H(n)w(n-1))\\
=w(n-1)+R^{-1}(n)r(n)-R^{-1}(n)R(n)w(n-1)
$$
等价于RLS 算法

#### 3.AP算法优缺点

- **优点**：收敛速度和计算复杂度介于 LMS 和RLS 之间

### 6.子带自适应滤波器（SAF）

#### 1.子带滤波器概述

一般来说，语音信号相比白色信号，前者明显有更大的频谱动态范围，即更大的信号相关性。因此，可以 **通过降低输入信号的相关性来加快算法收敛速度**，有效的一种方法就是是 子带自适应滤波算法，子带结构是基于频域对信号进行的一种处理（节省计算量、提高收敛速度）。

**子带自适应滤波器**（subband adaptive filter，SAF）：将相关信号通过**滤波器组**分割成近似无关的各个子带独立信号(子带分割)。然后对子带信号进行**多速率抽取**来获得采样信号，再进行信号的自适应处理。为研究子带自适应滤波器，首先需要了解 **多速率信号抽取系统** 和 **滤波器组** 。

#### 2.多速率系统

　用于 子带自适应滤波器 的多速率抽取系统 有 **下采样** 和 **上采样** 两种，主要通过 **抽取** 和 **插值** 方法来使系统获得不同采样率。输入信号经过 N 个滤波器分频后的总采样点数是原信号的 N 倍，大幅度提高的采样数增加了计算量。设采样因子是$K$，通过保留信号的$K$倍采样点可将采样速率从$f$减小为$\frac{f}{K}$，这样就降低了自适应算法的计算量。反之，上采样通过在信号相邻点间插入 K-1个 0 则使原采样率从$f$增大为$Kf$。

下采样过程可理解为将$x(n)$的频率进行$K$倍扩展，并进行$2\pi$的周期延拓，即生成了$x_D(n)$频谱。因此需要再前面加滤波器。

上采样过程频域表达式$X_I(e^{jw})$则是将$x(n)$的频率进行$K$倍压缩，再以$2\pi$为周期进行延拓得到。因此，需要在后面加滤波器。

#### 3.滤波器组

##### 1.滤波器组框图

​		信号子带分割通过滤波器组实现。滤波器组是由一系列的带通滤波器组成，主要包含以下环节：1)分析滤波器组，2)抽取，3)插值，4)综合滤波器组。分析滤波器组将数字信号分割后抽取成多个子带信号，经过信号处理后，综合滤波器组再对子带信号进行插值和滤波相加而恢复成原来的信号。

![img](https://img2020.cnblogs.com/blog/1433301/202106/1433301-20210611161926459-931359119.png)

　　分析滤波器组将输入信号$x(n)$分割为子带信号$x_i(k)$，每个子带信号占据输入信号频带的一部分。综合滤波器组将$N$个子带信号重建为输出信号$y(n)$。

　　传递函数均为带通滤波器，带宽一样，且中心频率是均匀分布的，滤波器覆盖全部频域，无重叠部分。采用 N 通道的均匀滤波器组分解全带信号，每个子带信号$X_i(z)$只包含全带信号$\frac{1}{N}$频带，因此子带信号可以用全带信号的 $\frac{1}{N}$倍采样率抽取，且能保留全部的原始信号信息。

　　如果滤波器组的采样因子恰好等于子带数，即$K=N$，这个滤波器组就称为**临界采样滤波器组**。临界采样使用 N 个采样子带信号保留了有效地采样率，每个子带信号，$X_{i}(x)$的采样率是全带信号$x(n)$采样率的$\frac{1}{N}$，因此所有子带信号样值数与全带信号样值数相等。

　　在综合过程中，子带信号$x_i(k)$采用相同的插值因子$K$，然后由综合滤波器组 合并为全带信号。因此，在重建全带信号$y(n)$时原来的采样率就被恢复了。

##### 2.无混叠QMF		

​		在实际应用中，滤波器存在过渡带和有限的阻带衰减，因此临界采样存在混叠的问题。正交镜像滤波器组(QMF)是无混叠的滤波器组：当插值信号$Y_i(z)$经过综合滤波器组合并为全带信号$Y(z)$时，混叠部分可以通过子带相互抵消。即使使用无混叠的 QMF 滤波器组，采样子带信号$X_i(z)$依然存在着混叠。当然，混叠信号可以利用理想的分析滤波器组消除，但是在现实中无法实现。

##### 3.余弦调制滤波器组

　　在实际应用中，可以使用余弦调制滤波器组来实现。学者们对余弦调制滤波器组的理论和设计进行了深入研究。余弦调制滤波器组的分析滤波器组和综合滤波器组都是 N 通道的临界采样滤波器组，它们可以用酉矩阵分别表达为$E(z) $和$R(z) $。

N 通道的余弦调制滤波器组的分析滤波器组和综合滤波器组都以低通滤波器为原型滤波器，这些低通滤波器的截止频率为$\frac{\pi}{2N}$。余弦调制的分析滤波器表示为
$$
H_i(z)=\alpha _iP[zW_{2N}^{(i+0.5)}]+\alpha _i^*P[zW_{2N}^{-(i+0.5)}],~~~~~~i=0,1,...,N-1
$$
其中，$W_{2 N}=e^{-j \pi / N}$是旋转因子，$\alpha_i$定义为 
$$
\alpha _i=exp\{j[\theta_i-\cfrac{\pi}{N}(i+0.5)(\cfrac{L-1}{2})]\}，~~~~~\theta_i = (-1)^i\cfrac{\pi}{4}
$$
L 是原型滤波器的长度。综合滤波器可以用分析滤波器的时域反转的形式表示
$$
F_i(z)=z^{-L+1}H_i(z^{-1})
$$
余弦调制分析滤波器 $H_i(z)$由两个复数滤波器组成，即$P\left[z W_{2 N}^{(i+0.5)}\right]$和$P\left[z W_{2 N}^{-(i+0.5)}\right]$，它们都由 P(z) 的复数调制产生，$P\left[z W_{2 N}^{(i+0.5)}\right]$的脉冲响应对应于$P\left[z W_{2 N}^{-(i+0.5)}\right]$的复共轭。

因此，分析滤波器组$H_i(z)$可以用实数脉冲响应表示:
$$
h_i(n)=2p(n)cos[\cfrac{\pi}{N}(i+0.5)(n-\cfrac{L-1}{2})+\theta_i]
$$
综合滤波器组$F_i(z)$用实数脉冲响应表示为 :
$$
f_i(n)=2p(n)cos[\cfrac{\pi}{N}(i+0.5)(n-\cfrac{L-1}{2})-\theta_i]
$$
通过优化原型滤波器的设计来满足一系列的预定限制，这样就能完全重构信号。不同的限制和优化方法可以推导出两种不同的余弦调制滤波器组类，即伪 QMF 余弦调制滤波器组和仿酉余弦调制滤波器组。

#### 4.子带自适应算法结构

在传统的 SAF中，子带自适应算法都是以最小化子带误差信号为目标的，这样基于局部目标函数误差的最小化不一定是全局误差能量最小化。而分析滤波器组在子带切割和综合滤波器组重建全带信号时皆会引入时延，在AEC 应用中，这样的时延会使包含近端语音的全带误差信号传到远端，为了消除时延的影响，无延时子带闭环结构系统以全局误差能量最小化为约束条件来调整滤波器系数。最后，确保自适应滤波算法能够收敛到最佳的滤波器系数。

##### 1.闭环结构子带自适应滤波器

下图所示是**闭环**无延时系统的结构图，无延时的子带自适应算法就是通过该结构来实现的。

![img](https://img2020.cnblogs.com/blog/1433301/202106/1433301-20210611155758902-1174246933.png)

该结构可以消除信道延迟带来的影响，将子带更新的抽头滤波器系数$W_i(z)$映射到全带自适应滤波器$W(z)$上，全带滤波器的表达式为：
$$
\hat W(z)=\sum_{i=0}^{K-1}\hat W_i(z^K)z^i
$$
从无延迟子带系统结构图中可以看出，输入信号直接经过实际房间脉冲响应后就可以得到期望信号$d(n)$，而预测信号$\hat{y}(n)$则还要经过分析滤波器组和自适应滤波器，这会导致两者间的时延，引入$\Delta $，作为一个补偿参数。C 是一个常数。子带自适应滤波器系数矩阵$w(n)$加入补偿因子后公式为：
$$
\Delta = \lfloor \cfrac{2NC-1}{K}\rfloor\\
\hat W_i(z)=\sqrt Kw_i(z)z^{-\cfrac{K-(i-1)}{K}+\Delta + 1}
$$

##### 2.开环结构子带自适应滤波器



![img](https://img-blog.csdnimg.cn/img_convert/92fd5659b6b85edb7512905a2227de68.png)

##### 3.归一化的子带自适应算法

为了针对SAF算法稳态误差较高的问题，提出了 基于最小扰动原理提出了**归一化的SAF（normalized SAF，NSAF）**算法。

NSAF 算法的滤波器权值系数更新迭代公式：
$$
e_{i,D}(k)=d_{i,D}(k)-x^T(k)\hat w(k),~~~~~i=0,1,...,N-1\\
\hat w(k) = \hat w(k-1)+\mu \sum_{i=0}^{N-1}\cfrac{e_{i,D(k)x_i(k)}}{\delta+||x_i(k)||_2^2}
$$
式中，$\delta $为正则化参数。

#### 5.SAF优缺点

- 优点：由于SAF类算法固有的去相关特性，改善了全带自适应滤波算法在相关信号条件下的收敛速率，NSAF在处理相关输入信号时比全带的NLMS收敛速度快，而且计算成本与NLMS不相上下
- 缺点：
  - 但其稳态误差由于输出时存在的混叠分量而显著升高
  - 子带系统将输出端会产生混叠分量，当采用正交镜像滤波器组时，虽然可以通过相互抵消掉混叠部分，但在现实中却无法实现

### 7.频域分块LMS（FDAF）

#### 1.时域分块LMS

$$
w(n+1)=w(n)+\mu \sum_{i=0}^{L-1}X(nL+i)e(nL+i)
$$

$y(n)=X^{T}(n) w(n)$：是输入向量与滤波器系数向量的**线性卷积**

$\hat{\nabla}(n)=-\sum_{i=0}^{L-1} X(n L+i) e(n L+i)$：是误差信号与输入向量的**线性相关**

#### 2.预备知识

线性卷积（相关）和圆周卷积（相关）之间的关系

1. 一般的，如果两个有限长序列的长度为$N_1$和$N_2$，且满足$N_1\geq N_2$，则有**圆周卷积**的**后** $N_1-N_2+1$个点，与**线性卷积**的结果一致。
2. 一般的，如果两个有限长序列的长度为$N_1$和$N_2$，且满足$N_1\geq N_2$，则有**圆周相关**的**前** $N_1-N_2+1$个点，与**线性相关**的结果一致。
3. 时域中的圆周卷积对应于其离散傅里叶变换的乘积。
4. 时域中的圆周相关对应于其离散傅里叶变换共轭谱的乘积。

#### 3.FDAF算法推导

##### 1.计算线性卷积

由于$N_1\geq N_2$ (输入信号长度通常大于滤波器的阶数)，且$N_2=N$ (滤波器的阶数为N)，为了计算FFT方便，令输入信号的长度为：$N_1=2N$，FFT的长度也为$2N$，即每次新进入N点数据。

为了构造长度为$2N$的数据，我们需要在每个$N$阶滤波器后面$N$补零

![img](https://img-blog.csdnimg.cn/img_convert/1a562c53bbfd9c8d252dcf323f82613c.png)

要求线性卷积(预备知识1)，即求圆周卷积后N个点；根据预备知识3，圆周卷积为离散傅里叶变换的乘积。
$$
Y(k)=X(k)W(k)
$$
$N$点线性卷积输出信号$y(k)$，就等于$Y(k)$的傅里叶逆变换的后N个点。

##### 2.计算线性相关

$$
\hat \nabla(n)=\sum_{i=0}^{L-1}X(nL+i)e(nL+i)
$$

根据预备知识2，4可知，需要求线性相关，我们可以通过获得 圆周相关 来获得。因此我们需要**求输入信号的共轭谱与误差信号谱的乘积**。

将误差向量$e(k)$也扩展到$2N$长度，因为是求**相关**，我们需要在误差向量**前面补0**，
$$
\Delta(k)=X^*(k)E(k)
$$
最后，将梯度向量进行傅里叶逆变换$\vec{\nabla}(k)=F^{-1} \Delta(k)$，取前$N$个点，就是我们求的线性相关。

##### 3.滤波器系数更新

$$
W(k+1)=W(k)+\mu F[\hat \nabla(k),0,0,...,0]
$$

- 第一，滤波器系数直接在频域更新，所以需要将梯度向量再次变换到频域；
- 第二，由于滤波器系数向量后面补了N 个零 ，为了保证结果的正确性梯度向量也需要在后面补 N 个零，主要是为了防止线性卷积变成循环卷积。

##### 4.学习速率的选取

利用输入信号在频点的功率对学习速率$P_m(k)$进行归一化：
$$
P_m(k)=\lambda P_m(k-1)+(1-\lambda)|X_m(k)|^2\\
\mu_m(k)=\cfrac{\mu}{P_m(k)}
$$


#### 4.FDAF算法框图

![img](https://img-blog.csdnimg.cn/img_convert/9a5f555e249a1e09b51f669152e6d2f2.png)

（1）进入新数据$x_{N}(n)$，组成$x(n)=[x_{past}(n),x_N(n)]$，做FFT得到$X(k)$。

（2）求频域相乘，$Y(k)=W(k)X(k)$，求$y(n)$为IFFT反变换后的后N个点。

（3）求误差估计，N点$e(n)=d(n)-y(n)$。

（4）拼接误差，前N点补零后做FFT，$E(k)=FFT[0,0,...,0,e(n)]$。

（5）计算更新值，$\Delta(k)=X^*(k)E(k)$。

（6）更新公式，$W(k+1)=W(k)+\mu FFT[\Delta ,0,0,...,0]$。

#### 5.FDAF的优缺点

- 优点
  - 降低了时域自适应滤波器的计算复杂度
  - 提高了收敛速度
- 缺点
  - 增加了延迟（需要通过频域滤波器延迟期望信号）
  - 增加了内存需求（需要同时存储激励信号和期望信号）

## 3.ANC耳机介绍

### 1.ANC分类

|   耳机ID   |     罩耳、入耳式、耳塞式、贴耳、半入耳      |
| :--------: | :-----------------------------------------: |
|   信号流   |            前馈、反馈、前馈+反馈            |
| 滤波器控制 | 固定系数滤波、半自适应、自适应、固定+自适应 |
| 滤波器实现 |              FIR、IIR、IIR+FIR              |

客观评价指标：测量插入损失法

主观评价指标

### 2.前馈、反馈、前馈加反馈

#### 1.前馈ANC

优点：可以更快做出响应，对频率为1-2kHZ的高频声音有很好的降噪效果

缺点：参考信号接收风噪，会产生无意义的风噪反向信号，耳机会有风噪声音；如果耳机没有被正确佩戴，效果会大打折扣。

#### 2.反馈ANC

**优点：**

- 可以在更宽的频率范围内工作。
- 可以适应噪音的变化，及时校正。即使佩戴不正确也不会对降噪性能有太大影响

**缺点：**

- 无法进行高频信号的处理。
- 而且由于拾音麦克风靠近耳道，耳机自己播放的音乐/语音可能也会被过滤掉部分。
- 除此之外，还可能存在反馈噪声
- 会不稳定，有可能会产生啸叫

#### 3.前馈加反馈

**优点：**

- 可以抑制高频，并在可在更宽频率上工作
- 自适应。即使佩戴不正确也不会对降噪性能有太大影响

**缺点：**

- 需要多组麦克风配合工作，设计复杂
- 需要更高质量的麦克风来减少工作时产生的不必要噪音，成本高

### 3.混馈ANC介绍

都假设了电设备的输入输出一致，但实际会有非线性耦合问题。

<img src="https://gitee.com/qian-mi/typora_picture/raw/master/img/202209211547778.png" alt="image-20220921154344043" style="zoom:80%;" />

降低前馈延迟，提高采样频率，可选取192kHz，或是384~768kHz，此时延迟一般低于10微秒

反馈控制器要消除腔体的共振，反馈控制器需要尽量降低处理延迟从而消除具有相关性的噪声。



为了降低延迟，目前常采用的数字ANC芯片，采用超高采样率192k、384k、768k，目前由于算例、功耗等原因不支持超高采样频率下的FIR滤波器卷积。

普遍采用**多个均衡器型IIR双二阶节**组合逼近期望的滤波器响应；通过对单个IIR双二阶节零、极点的调节以及多个IIR双二阶节的级联，获得控制器所需要的相位响应。

|   ANC类型    | 耳机控制频宽 | 最大降噪深度 |
| :----------: | :----------: | :----------: |
|  前馈型ANC   |  30~1200Hz   |     30dB     |
|  反馈型ANC   |   30~500Hz   |     20dB     |
| 前馈+反馈ANC |  30~1200Hz   |     50dB     |

影响效果因素：

- 次级通路有平顺的幅频响应；
- 硬件扬声器、麦克风的选型应有充分的低频响应，在高噪声环境下可以给予充分的降噪幅度；
- 耳机外壳设计应具有良好的密闭性，使反馈所需的共振峰会比较明显；

造成耳机传递函数差异的因素（相位响应变化不明显、幅频响应变化比较大）：

- 人的生理参数不同，如耳廓、耳道尺寸不同；
- 耳机佩戴习惯不同，如松、紧不同；
- 耳机电声器件产品不同；

在线辨识不同佩戴状态，采用虚拟传声器技术，可以自适应实现不同佩戴状况下的最优化ANC效果。
